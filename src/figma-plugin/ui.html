<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Fiber Twist Pattern Generator</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1D1D1D;
      color: white;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    .container {
      display: flex;
      width: 100%;
      height: 100vh;
      position: relative;
    }

    .background-blur {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: blur(80px) brightness(0.4);
      z-index: 0;
      pointer-events: none;
    }

    .main-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
      z-index: 1;
      overflow: auto;
    }

    .canvas-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      width: 100%;
      align-items: center;
    }

    .canvas-container {
      width: 100%;
      max-width: 80vw;
      overflow: hidden;
      position: relative;
      border-radius: 0.5rem;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }

    .controls-bottom {
      width: 100%;
      max-width: 90vw;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding-top: 1.5rem;
    }

    .control-row {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .side-panel {
      width: 380px;
      min-width: 380px;
      background-color: rgba(29, 29, 29, 0.3);
      padding: 2rem;
      overflow-y: auto;
      max-height: 100vh;
      border-left: 1px solid rgba(64, 64, 64, 0.3);
      position: relative;
      z-index: 1;
    }

    .button-group {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    button {
      background: rgba(64, 64, 64, 0.35);
      color: white;
      padding: 0.625rem 1rem;
      border-radius: 0.5rem;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    button:hover {
      background: rgba(84, 84, 84, 0.45);
    }

    .btn-primary {
      background: rgba(255, 255, 255, 0.35);
      font-weight: 600;
    }

    .btn-primary:hover {
      background: rgba(255, 255, 255, 0.45);
    }

    select {
      width: 100%;
      background: rgba(64, 64, 64, 0.35);
      color: white;
      padding: 0.625rem 0.75rem;
      border-radius: 0.5rem;
      border: none;
      font-size: 0.875rem;
      cursor: pointer;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='white' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      padding-right: 2.5rem;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      width: 100%;
      height: 0.5rem;
      border-radius: 0.5rem;
      cursor: pointer;
      outline: none;
      border: none;
    }

    input[type="range"]::-webkit-slider-track {
      background: rgba(64, 64, 64, 0.35);
      height: 0.5rem;
      border-radius: 0.5rem;
      border: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 0.875rem;
      height: 0.875rem;
      background: white;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      margin-top: -0.1875rem;
    }

    input[type="range"]::-moz-range-track {
      background: rgba(64, 64, 64, 0.35);
      height: 0.5rem;
      border-radius: 0.5rem;
      border: none;
    }

    input[type="range"]::-moz-range-thumb {
      width: 0.875rem;
      height: 0.875rem;
      background: white;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .control-label {
      font-size: 13px;
      color: #d4d4d4;
      margin-bottom: 0.25rem;
      display: block;
    }

    .section-title {
      font-size: 14px;
      font-weight: 500;
      color: white;
      margin-bottom: 0.75rem;
      margin-top: 0;
    }

    .control-item {
      margin-bottom: 0.5rem;
    }

    .color-palette {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .color-swatch {
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }

    .color-swatch.active {
      border-color: #84cc16;
    }

    .logos {
      position: absolute;
      top: 2rem;
      left: 2rem;
      z-index: 5;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .logo-placeholder {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="background-blur" id="backgroundBlur"></div>
    
    <div class="main-content">
      <div class="canvas-wrapper">
        <div class="canvas-container" id="canvasContainer">
          <canvas id="patternCanvas"></canvas>
        </div>

        <div class="controls-bottom">
          <!-- Animation Controls -->
          <div class="control-row">
            <select id="animationType">
              <option value="pulse">Pulse</option>
              <option value="wave">Wave</option>
              <option value="rotation">Rotation</option>
              <option value="flow">Flow</option>
            </select>

            <div style="display: flex; align-items: center; gap: 0.5rem; background: rgba(64, 64, 64, 0.3); padding: 0.625rem 1rem; border-radius: 0.5rem; min-width: 200px;">
              <label style="font-size: 0.875rem; white-space: nowrap;">Speed: <span id="speedValue">0.5</span>x</label>
              <input type="range" id="animationSpeed" min="0.1" max="2" step="0.1" value="0.5" style="flex: 1;">
            </div>

            <button id="toggleAnimation">▶ Play</button>
            <div style="background: rgba(64, 64, 64, 0.3); padding: 0.625rem 1rem; border-radius: 0.5rem; font-size: 0.875rem;">
              <span id="animationStatus">Static Mode</span>
            </div>
          </div>

          <!-- Export Controls -->
          <div class="control-row">
            <select id="aspectRatio">
              <option value="16:9">16:9 (Landscape)</option>
              <option value="1:1">1:1 (Square)</option>
              <option value="3:4">3:4 (Portrait)</option>
              <option value="9:16">9:16 (Mobile)</option>
            </select>

            <select id="exportFormat">
              <option value="png">PNG</option>
              <option value="jpg">JPG</option>
            </select>

            <div style="display: flex; align-items: center; gap: 0.5rem; background: rgba(64, 64, 64, 0.3); padding: 0.625rem 1rem; border-radius: 0.5rem;">
              <input type="checkbox" id="transparentBg">
              <label for="transparentBg" style="font-size: 0.875rem; cursor: pointer;">Transparent BG</label>
            </div>

            <button id="insertToFigma" class="btn-primary">Insert to Figma</button>
            <button id="exportPattern">↓ Download</button>
          </div>

          <!-- Color Controls -->
          <div class="control-row">
            <div style="flex: 1;">
              <label class="control-label">Background Color</label>
              <input type="color" id="backgroundColor" value="#000000" style="width: 3rem; height: 3rem; border-radius: 0.5rem; border: none; cursor: pointer;">
            </div>
            <div style="flex: 3;">
              <label class="control-label">Color Palette</label>
              <div class="color-palette" id="colorPalette"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <div class="button-group">
        <button id="resetButton" style="flex: 0; width: 2.5rem; padding: 0.625rem;">⟲</button>
        <button id="randomizeButton" style="flex: 1;">Randomize Pattern</button>
      </div>

      <div style="margin-bottom: 1.5rem;">
        <h2 class="section-title">Pattern Controls</h2>
        
        <div class="control-item">
          <label class="control-label">Line Thickness: <span id="thicknessValue">12</span></label>
          <input type="range" id="thickness" min="3" max="20" value="12">
        </div>

        <div class="control-item">
          <label class="control-label">Thickness Variation: <span id="thicknessVariationValue">20</span>%</label>
          <input type="range" id="thicknessVariation" min="0" max="2" step="0.1" value="0.2">
        </div>

        <div class="control-item">
          <label class="control-label">Motion Blur: <span id="motionBlurValue">0</span>%</label>
          <input type="range" id="motionBlur" min="0" max="1" step="0.05" value="0">
        </div>

        <div class="control-item">
          <label class="control-label">Bulge Amount: <span id="bulgeValue">40</span>%</label>
          <input type="range" id="bulge" min="0.1" max="0.6" step="0.05" value="0.4">
        </div>

        <div class="control-item">
          <label class="control-label">Overall Rotation: <span id="twistRotationValue">0.5</span> rotations</label>
          <input type="range" id="twistRotation" min="0" max="2" step="0.1" value="0.5">
        </div>

        <div class="control-item">
          <label class="control-label">Wave Strength: <span id="twistValue">0.6</span></label>
          <input type="range" id="twist" min="0.3" max="2" step="0.1" value="0.6">
        </div>

        <div class="control-item">
          <label class="control-label">Line Density: <span id="densityValue">45</span></label>
          <input type="range" id="density" min="20" max="100" value="45">
        </div>

        <div class="control-item">
          <label class="control-label">Color Repeats: <span id="colorRepeatsValue">2</span> cycles</label>
          <input type="range" id="colorRepeats" min="1" max="8" value="2">
        </div>

        <div class="control-item">
          <label class="control-label">Opacity: <span id="opacityValue">100</span>%</label>
          <input type="range" id="opacity" min="0.3" max="1" step="0.05" value="1">
        </div>

        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(64, 64, 64, 0.5);">
          <h3 class="section-title">Post Effects</h3>
        </div>

        <div class="control-item">
          <label class="control-label">Post Blur: <span id="postBlurValue">0</span>%</label>
          <input type="range" id="postBlur" min="0" max="1" step="0.05" value="0">
        </div>

        <div class="control-item">
          <label class="control-label">Film Grain: <span id="postNoiseValue">0</span>%</label>
          <input type="range" id="postNoise" min="0" max="1" step="0.05" value="0">
        </div>
      </div>
    </div>
  </div>

  <script>
    // State
    let state = {
      colors: ["#1a0000", "#4a0404", "#8B0000", "#A52A2A", "#DC143C", "#FF6B6B", "#FF9999", "#FFE5E5"],
      thickness: 12,
      thicknessVariation: 0.2,
      motionBlur: 0,
      bulge: 0.4,
      twist: 0.6,
      twistRotation: 0.5,
      density: 45,
      colorRepeats: 2,
      opacity: 1,
      postBlur: 0,
      postNoise: 0,
      backgroundColor: "#000000",
      aspectRatio: "16:9",
      exportFormat: "png",
      transparentBg: false,
      seed: Math.random(),
      isAnimating: false,
      animationSpeed: 0.5,
      animationType: "pulse",
      animationTime: 0
    };

    const canvas = document.getElementById('patternCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let animationFrameId = null;

    // Color palettes
    const colorPalettes = [
      ["#1a0000", "#4a0404", "#8B0000", "#A52A2A", "#DC143C", "#FF6B6B", "#FF9999", "#FFE5E5"],
      ["#1C0010", "#5C0A2C", "#800020", "#C41E3A", "#FF69B4", "#FFB6C1", "#FFD1DC", "#FFF0F5"],
      ["#2B0000", "#6B1515", "#A52A2A", "#CD5C5C", "#FFA07A", "#FFE4E1", "#FFF0ED", "#FFFAFA"],
      ["#1B0042", "#4B0082", "#6A0DAD", "#8B008B", "#DA70D6", "#FF99D8", "#FFB3E6", "#FFF0FF"],
      ["#0D0000", "#3D0000", "#8B0000", "#B22222", "#CD5C5C", "#FFC0CB", "#FFD7D7", "#FFF5F5"],
      ["#1A0517", "#4A0E4E", "#6A0572", "#AB2567", "#FF6B9D", "#FFB3D9", "#FFD1E8", "#FFF5FA"]
    ];

    // Utility functions
    function seededRandom(s) {
      const x = Math.sin(s) * 10000;
      return x - Math.floor(x);
    }

    function parseColor(colorStr) {
      if (colorStr.startsWith('#')) {
        const hex = colorStr.slice(1);
        return [
          parseInt(hex.slice(0, 2), 16),
          parseInt(hex.slice(2, 4), 16),
          parseInt(hex.slice(4, 6), 16)
        ];
      }
      return [0, 0, 0];
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0, s = 0, l = (max + min) / 2;

      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }
      return [h * 360, s * 100, l * 100];
    }

    function hslToRgb(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function interpolateColorHSL(color1, color2, t) {
      const c1 = parseColor(color1);
      const c2 = parseColor(color2);
      const hsl1 = rgbToHsl(c1[0], c1[1], c1[2]);
      const hsl2 = rgbToHsl(c2[0], c2[1], c2[2]);

      let h1 = hsl1[0];
      let h2 = hsl2[0];
      if (Math.abs(h2 - h1) > 180) {
        if (h2 > h1) h1 += 360;
        else h2 += 360;
      }

      const h = (h1 + (h2 - h1) * t) % 360;
      const s = hsl1[1] + (hsl2[1] - hsl1[1]) * t;
      const l = hsl1[2] + (hsl2[2] - hsl1[2]) * t;
      const rgb = hslToRgb(h, s, l);
      return `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
    }

    // Draw pattern
    function drawPattern(time = 0) {
      canvas.width = 1600;
      canvas.height = 1600;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      if (state.transparentBg) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = state.backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      drawMainPattern(time);
      applyPostEffects();
      updateBackgroundBlur();
    }

    function drawMainPattern(time) {
      const numLines = state.density;
      const twistPhase = state.seed * Math.PI * 2;
      let timeOffset = 0;

      if (state.isAnimating) {
        if (state.animationType === 'wave') timeOffset = time * 2;
        else if (state.animationType === 'rotation') timeOffset = time * Math.PI * 2;
        else if (state.animationType === 'pulse') timeOffset = Math.sin(time * 3) * 0.5;
        else if (state.animationType === 'flow') timeOffset = time * 3;
      }

      for (let i = 0; i < numLines; i++) {
        const progress = i / numLines;
        const colorProgress = (progress * state.colorRepeats * state.colors.length) % state.colors.length;
        const colorIndex = Math.floor(colorProgress);
        const colorT = colorProgress - colorIndex;
        const nextIndex = (colorIndex + 1) % state.colors.length;

        const baseColor = interpolateColorHSL(
          state.colors[colorIndex],
          state.colors[nextIndex],
          colorT
        );

        const normalizedY = progress - 0.5;
        const baseY = canvas.height * 0.5;
        const clusterSeed = Math.floor(i / 5) * 0.2;
        const baseRandom = seededRandom(state.seed + clusterSeed);
        const randomFactor = 1 - state.thicknessVariation / 2 + baseRandom * state.thicknessVariation;

        let animatedThickness = state.thickness * randomFactor;
        if (state.isAnimating && state.animationType === 'pulse') {
          animatedThickness *= 1 + timeOffset * 0.2;
        }

        const segments = 400;
        ctx.beginPath();
        ctx.lineWidth = animatedThickness;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        for (let j = 0; j <= segments; j++) {
          const t = j / segments;
          const x = t * canvas.width;

          let animatedRotation = state.twistRotation;
          let animatedTwist = state.twist;

          if (state.isAnimating) {
            if (state.animationType === 'wave') {
              animatedTwist = state.twist + Math.sin(t * Math.PI * 4 + timeOffset) * 0.3;
            } else if (state.animationType === 'rotation') {
              animatedRotation = state.twistRotation + timeOffset;
            } else if (state.animationType === 'flow') {
              animatedRotation = state.twistRotation + t * timeOffset * 0.3;
            }
          }

          const rotationAngle = t * Math.PI * 2 * animatedRotation + twistPhase;
          const rotatedOffset = normalizedY * Math.cos(rotationAngle);
          const depthOffset = normalizedY * Math.sin(rotationAngle);
          const bulgeCurve = Math.sin(t * Math.PI) * state.bulge * canvas.height;
          const twistCurve = Math.sin(
            t * Math.PI * animatedTwist + twistPhase + progress * Math.PI + (state.isAnimating ? timeOffset : 0)
          ) * canvas.height * 0.15;

          const perspectiveScale = 1 + Math.sin(t * Math.PI) * 0.3;
          const depthScale = 1 - depthOffset * 0.3;
          const lineOffset = rotatedOffset * canvas.height * 0.4 * depthScale;
          const y = baseY + lineOffset * perspectiveScale + bulgeCurve + twistCurve;

          if (j === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        ctx.strokeStyle = baseColor;
        ctx.globalAlpha = state.opacity;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    function applyPostEffects() {
      if (state.postBlur > 0) {
        ctx.filter = `blur(${state.postBlur * 10}px)`;
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
      }

      if (state.postNoise > 0) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const noiseIntensity = state.postNoise * 50;

        for (let i = 0; i < data.length; i += 4) {
          if (data[i + 3] > 0) {
            const noise = (Math.random() - 0.5) * noiseIntensity;
            data[i] = Math.max(0, Math.min(255, data[i] + noise));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
          }
        }
        ctx.putImageData(imageData, 0, 0);
      }
    }

    function updateBackgroundBlur() {
      if (!state.isAnimating) {
        const dataUrl = canvas.toDataURL('image/png');
        document.getElementById('backgroundBlur').style.backgroundImage = `url(${dataUrl})`;
      }
    }

    function updateCanvasSize() {
      const container = document.getElementById('canvasContainer');
      const ratio = state.aspectRatio;
      
      if (ratio === '16:9') {
        container.style.maxWidth = '80vw';
        container.style.aspectRatio = '16/9';
      } else if (ratio === '9:16') {
        container.style.maxWidth = '40vh';
        container.style.aspectRatio = '9/16';
      } else if (ratio === '3:4') {
        container.style.maxWidth = '50vh';
        container.style.aspectRatio = '3/4';
      } else {
        container.style.maxWidth = '70vh';
        container.style.aspectRatio = '1/1';
      }
    }

    // Animation loop
    function animate() {
      if (state.isAnimating) {
        state.animationTime += 0.016 * state.animationSpeed;
        drawPattern(state.animationTime);
        animationFrameId = requestAnimationFrame(animate);
      }
    }

    // Event listeners
    document.getElementById('toggleAnimation').addEventListener('click', () => {
      state.isAnimating = !state.isAnimating;
      const btn = document.getElementById('toggleAnimation');
      const status = document.getElementById('animationStatus');
      
      if (state.isAnimating) {
        btn.textContent = '⏸ Pause';
        status.textContent = 'Preview Mode';
        animate();
      } else {
        btn.textContent = '▶ Play';
        status.textContent = 'Static Mode';
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        drawPattern(state.animationTime);
      }
    });

    document.getElementById('randomizeButton').addEventListener('click', () => {
      state.seed = Math.random();
      state.colors = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];
      renderColorPalette();
      drawPattern(state.animationTime);
    });

    document.getElementById('resetButton').addEventListener('click', () => {
      state = {
        ...state,
        thickness: 12,
        thicknessVariation: 0.2,
        motionBlur: 0,
        bulge: 0.4,
        twist: 0.6,
        twistRotation: 0.5,
        density: 45,
        colorRepeats: 2,
        opacity: 1,
        postBlur: 0,
        postNoise: 0,
        backgroundColor: '#000000',
        transparentBg: false,
        animationSpeed: 0.5,
        animationType: 'pulse',
        isAnimating: false
      };
      updateAllControls();
      drawPattern(state.animationTime);
    });

    document.getElementById('insertToFigma').addEventListener('click', () => {
      const imageData = canvas.toDataURL('image/png');
      parent.postMessage({
        pluginMessage: {
          type: 'create-pattern',
          imageData: imageData,
          aspectRatio: state.aspectRatio
        }
      }, '*');
    });

    document.getElementById('exportPattern').addEventListener('click', () => {
      const link = document.createElement('a');
      if (state.exportFormat === 'jpg') {
        link.download = 'fiber-twist-pattern.jpg';
        link.href = canvas.toDataURL('image/jpeg', 0.95);
      } else {
        link.download = 'fiber-twist-pattern.png';
        link.href = canvas.toDataURL('image/png');
      }
      link.click();
    });

    // Range input listeners
    function setupRangeInput(id, stateKey, valueId, formatter = (v) => v) {
      const input = document.getElementById(id);
      const valueSpan = document.getElementById(valueId);
      
      input.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        state[stateKey] = value;
        valueSpan.textContent = formatter(value);
        drawPattern(state.animationTime);
      });
    }

    setupRangeInput('thickness', 'thickness', 'thicknessValue');
    setupRangeInput('thicknessVariation', 'thicknessVariation', 'thicknessVariationValue', v => Math.round(v * 100));
    setupRangeInput('motionBlur', 'motionBlur', 'motionBlurValue', v => Math.round(v * 100));
    setupRangeInput('bulge', 'bulge', 'bulgeValue', v => Math.round(v * 100));
    setupRangeInput('twistRotation', 'twistRotation', 'twistRotationValue', v => v.toFixed(1));
    setupRangeInput('twist', 'twist', 'twistValue', v => v.toFixed(1));
    setupRangeInput('density', 'density', 'densityValue');
    setupRangeInput('colorRepeats', 'colorRepeats', 'colorRepeatsValue');
    setupRangeInput('opacity', 'opacity', 'opacityValue', v => Math.round(v * 100));
    setupRangeInput('postBlur', 'postBlur', 'postBlurValue', v => Math.round(v * 100));
    setupRangeInput('postNoise', 'postNoise', 'postNoiseValue', v => Math.round(v * 100));
    setupRangeInput('animationSpeed', 'animationSpeed', 'speedValue', v => v.toFixed(1));

    document.getElementById('animationType').addEventListener('change', (e) => {
      state.animationType = e.target.value;
    });

    document.getElementById('aspectRatio').addEventListener('change', (e) => {
      state.aspectRatio = e.target.value;
      updateCanvasSize();
    });

    document.getElementById('exportFormat').addEventListener('change', (e) => {
      state.exportFormat = e.target.value;
    });

    document.getElementById('transparentBg').addEventListener('change', (e) => {
      state.transparentBg = e.target.checked;
      drawPattern(state.animationTime);
    });

    document.getElementById('backgroundColor').addEventListener('input', (e) => {
      state.backgroundColor = e.target.value;
      drawPattern(state.animationTime);
    });

    function renderColorPalette() {
      const palette = document.getElementById('colorPalette');
      palette.innerHTML = '';
      state.colors.forEach((color, i) => {
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = color;
        swatch.addEventListener('click', () => {
          const newColor = prompt('Enter new color (hex):', color);
          if (newColor) {
            state.colors[i] = newColor;
            renderColorPalette();
            drawPattern(state.animationTime);
          }
        });
        palette.appendChild(swatch);
      });
    }

    function updateAllControls() {
      document.getElementById('thickness').value = state.thickness;
      document.getElementById('thicknessValue').textContent = state.thickness;
      document.getElementById('thicknessVariation').value = state.thicknessVariation;
      document.getElementById('thicknessVariationValue').textContent = Math.round(state.thicknessVariation * 100);
      document.getElementById('motionBlur').value = state.motionBlur;
      document.getElementById('motionBlurValue').textContent = Math.round(state.motionBlur * 100);
      document.getElementById('bulge').value = state.bulge;
      document.getElementById('bulgeValue').textContent = Math.round(state.bulge * 100);
      document.getElementById('twistRotation').value = state.twistRotation;
      document.getElementById('twistRotationValue').textContent = state.twistRotation.toFixed(1);
      document.getElementById('twist').value = state.twist;
      document.getElementById('twistValue').textContent = state.twist.toFixed(1);
      document.getElementById('density').value = state.density;
      document.getElementById('densityValue').textContent = state.density;
      document.getElementById('colorRepeats').value = state.colorRepeats;
      document.getElementById('colorRepeatsValue').textContent = state.colorRepeats;
      document.getElementById('opacity').value = state.opacity;
      document.getElementById('opacityValue').textContent = Math.round(state.opacity * 100);
      document.getElementById('postBlur').value = state.postBlur;
      document.getElementById('postBlurValue').textContent = Math.round(state.postBlur * 100);
      document.getElementById('postNoise').value = state.postNoise;
      document.getElementById('postNoiseValue').textContent = Math.round(state.postNoise * 100);
      document.getElementById('animationSpeed').value = state.animationSpeed;
      document.getElementById('speedValue').textContent = state.animationSpeed.toFixed(1);
      document.getElementById('backgroundColor').value = state.backgroundColor;
      document.getElementById('transparentBg').checked = state.transparentBg;
    }

    // Listen for messages from Figma
    window.addEventListener('message', (event) => {
      const msg = event.data.pluginMessage;
      if (msg && msg.type === 'pattern-created') {
        if (msg.success) {
          alert('Pattern inserted to Figma!');
        } else {
          alert('Error: ' + msg.error);
        }
      }
    });

    // Initialize
    renderColorPalette();
    updateCanvasSize();
    drawPattern(0);
  </script>
</body>
</html>
